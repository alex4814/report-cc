\documentclass[12pt,letter]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}

\usepackage{hyperref}
\hypersetup{colorlinks=true}

\usepackage[numbers,sort&compress]{natbib}
\usepackage{hypernat}

\bibliographystyle{plainurl}

\author{Ruisheng Fu\\21421190\\CCNT Lab.
\and
Guanyu Guo\\21421189\\LIST Lab.
\and
Chen Sui\\21421183}
\title{NoSQL in Cloud Computing}
\date{\today}

\begin{document}
\maketitle
\tableofcontents

\begin{abstract}
A lot of changes in database management system has been made since the inception of cloud computing. Such critical and increasing needs within cloud computing as scalability, elasticity and  processing a huge amount of data can be fulfilled by the NoSQL databases as opposed to RDBMS\footnote{Relational Database Management System}. In this report we have dived into several primary NoSQL databases used in leading cloud vendors, summarizing and discussing detailed techniques as well as analysis with comparisons.
\end{abstract}

\section{Introduction}
Cloud computing has been a evolving computing terminology that is very much in the public eye. It is its responsibility to manage and group remote servers that allow data storage and online access to various services. 

In the field of computing, the various advancements and aspects are key evidences that explain the reason why higher priorities are given to scalability, resource utilization and power savings, with respect to data storage, rather than consistency. The traditional RDBMSs offer functionalities like clustering, synchronization (always consistent), load balancing and structured querying. However, what classical RDBMS could not do so well is to scale\footnote{Scaling, in a google sense, means that an application runs on small commodity PC hardware, but supports essentially unbounded load as more PC’s are added. } to heavy workloads compared to NoSQL databases. As non-relational databases have cropped up both inside and outside the cloud, there comes heated debate around SQL and NoSQL.\citep{Bain2009}

The two solutions, manual sharding and caching, applied to classical SQL databases are not adequate enough to cope up with the modern web applications, thus agility can't be achieved. On the contrary, NoSQL databases is designed to handle such sort of problems. In those applications where high availability, speed, fault tolerance or consistency are needed, NoSQL is the choice, in that it is designed to scale out, to provide elasticity and to be highly available. The misleading term \textit{NoSQL} should be seen as the definition\citep{Unknown2012} that is "Next Generation Databases mostly addressing some of the points: being non-relational, distributed, open-source and horizontally scalable", and is mostly translated with "Not only SQL".

In this report, we firstly examine several major NoSQL databases implemented and used in cloud vendors like Google, Amazon, and Yahoo, along with description about the main ideas of each design. Afterwards, analysis towards different NoSQL databases and we present benchmarking of top NoSQL as a visualizing comparison. Finally, a brief summarization is included in conclusion and further studies as well as challenges is discussed.

\section{Major Streams}
Currently there are approximately 150 NoSQL databases categorized by data models into a bunch of classes.\citep{Unknown2012} We review certain amount of prevailing NoSQL databases through several aspects, including data model, partitions, availability, and consistency. \citep{Suter2012} makes a brief introduction to MongoDB with an installation guide, and mainly focus on the performance benchmark.

\subsection{Data Model}
The major data models adopted we are going to investigate are Wide Column Store (Column Families), Document Store, and Key Value Store, whereas the minor ones (Graph Databases, Object Databases, etc.) are beyond our scope of discussion in this report.

\paragraph*{Column Family Store}
Columnar databases are logically similar to tabular databases. The difference is that the data are  column-wise stored and retrieved.

(BigTable)

Casandra comes under column family. It is designed to process the data which are spread across different servers without a single point failure. Columns in Cassandra are grouped together very much similar to what happens in the BigTable\citep{Chang2006} system. Cassandra\citep{LakshamAvinash2010} exposes two kinds of columns families, \textit{Simple} and \textit{Super} column families. Super column families can be visualized as a column family within a column family. Casandra also allows columns to be sorted either by time or by name, which is often exploited by different applications.

\paragraph*{Document Store}
A document-oriented database eschews the table-based relational database structure. MongoDB is the well-known member of the family. In general, it stores business subjects in the minimal number of documents instead of breaking it up into relational structures\citep{Hoberman2014} in favor of JSON-like formats with dynamic schemas.\citep{Suter2012} This flexibility facilitates the mapping of documents to an entity or an object in MongoDB, in which there are two tools to allow applications to represent relationships between data: \textit{references} and \textit{embedded documents}.\citep{MongoDBInc.2009}

\paragraph*{Key Value Store}


\subsection{Availability}
As server downtime implies lost revenue, high availability is the key factor to sustain services. To achieve this goal, various methods has emerged.

\paragraph*{Replication}
Replication is one way to ensure consistency between redundant resources, to improve reliability, fault-tolerance, or accessibility. 


There are two types of replication supported in MongoDB: \textit{master-slave} and \textit{replica sets}.\citep{Suter2012} The latter works the same as the former, except that it is possible to elect a new master if the original master went down.

\paragraph*{Load Balancing} 

\paragraph*{Failure Detection}

\subsection{Partition}
Due to huge amount of data across applications, it needs to partition the data to distribute it over a cluster. There are two main approaches for partitioning: \textit{sharding}, \textit{range partition} and \textit{hash partition}. The ability to dynamically partition the data over nodes ensures scaling incrementally. 

\paragraph*{Sharding}
Sharding is a method for storing data across multiple machines. (http://docs.mongodb.org/manual/core/sharding-introduction/)

Another feature supported by MongoDB is automatic sharding [7]. Using this feature the data can be partitioned over multiple nodes. The administrator only has to define a sharding key for each collection which defines how to partition the contained docu- ments. In such an environment, the clients connect to a special master node called mongos process which analyses the query and redirects it to the appropriate node or nodes. To avoid data losses, every logical node can consist of multiple physical servers which act as a replica set. Using this node infra- structure it is also possible to use Map/Reduce [8] to work on the available data set having a very good performance.

\paragraph*{Range}
What range partition does is to order records lexicographically based on keys and divide it according to the ordering result.

\paragraph*{Hashing}
By hashing, we mean that hash records based on key to a linear space and then divide space among different servers.

Cassandra partitions data across the cluster using \textit{consistent hashing} but uses an order preserving hash function to do so. In \citep{LakshamAvinash2010}, it points out the challenges (non-uniform data and load distribution) the basic consistent hashing algorithm\citep{Karger1997} is facing, and adopt the latter of two suggested ways in \citep{Stoica2003} to address these issues, because it makes the design and implementation tractable and helps to make choices about load balancing.



\subsection{Consistency}

\section{Performance}

\section{Conclusion}
CAP consistency, availability, partition
only 2 of 3

\subsection{Drawback}
Transactions are not directly supported by MongoDB. Though there are two workarounds: atomic operations and two-phase commits. Atomic operations allow performing multiple operations in one call. An example is findAndModify [9] or the inc [10] operator used in updates.
There are several other limitations. For example, if you use the 32-bit version of MongoDB the data set is limited to a size of 2.5 gigabytes [11]. MongoDB does not support full single server durability which means you need multiple replications to avoid data losses if one server suffers a power loss or crash [12]. Another drawback is the fact that it uses much more storage space for the same data then for example PostgreSQL. Because – as opposed to relational databases – every document can have different keys [13] the whole document has to be stored, not only the values. That’s why it is recommended to use short key names.

\section*{Help}
\subsection*{2}
What reporting verbs should I use?
Avoid over-using "states" and "says". You may need to use tentative or evaluative verbs.
• Tentative verbs are often used to show that findings are incomplete or difficult to generalise from.
e.g. Research suggests that a majority of people prefer email to... (Mahlab 1995). Wang (2003) indicates that such results are not necessarily...
• Evaluative verbs can pack in extra meaning by incorporating your evaluation of the text. e.g. Jacob concedes that the test is not 100 per cent reliable.
This is much stronger than "Jacob states that... " since concedes includes the judgement that Jacob was reluctant to make the acknowledgement.
Some other strong reporting words are:
describe, contend, examine, assert, dispute, claim, purport, persuade, refute, concur, recommend, object, dismiss, contradict, propose, examine, observe

\subsection*{3}
It really depends on the needs of your application. For web applications that have light querying, key/value stores are very useful. For enterprise databases where reporting is typically very heavy, relational databases fit better. I cannot really comment on systems like Cache as I have not used them.

\bibliography{refs}

\end{document}